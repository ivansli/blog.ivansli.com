<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>etcd与分布式锁的实现及原理 | 极客之道</title><meta name="keywords" content="etcd与分布式锁的实现及原理"><meta name="author" content="ivansli"><meta name="copyright" content="ivansli"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="etcd与分布式锁的实现及原理"><meta name="application-name" content="etcd与分布式锁的实现及原理"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="etcd与分布式锁的实现及原理"><meta property="og:url" content="https://blog.ivansli.com/2021/05/24/etcd-lock/index.html"><meta property="og:site_name" content="极客之道"><meta property="og:description" content="etcd与分布式锁的实现及原理"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog.ivansli.com/img/space-man-small.png"><meta property="article:author" content="ivansli"><meta property="article:tag" content="伊万的小站,ivansli,编程技术,编程技术之道,编程原理,go开发技巧"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.ivansli.com/img/space-man-small.png"><meta name="description" content="etcd与分布式锁的实现及原理"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.ivansli.com/2021/05/24/etcd-lock/"><link rel="preconnect"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: undefined,
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: ivansli","link":"链接: ","source":"来源: 极客之道","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '极客之道',
  title: 'etcd与分布式锁的实现及原理',
  postAI: '',
  pageFillDescription: '1.关于etcd, 2.实现分布式锁的组件们, 3.etcd分布式锁实现原理, 4.etcd分布式锁示例代码, 5.源码解读, 6.小结, 7.扩展阅读关于官方文档永远是最好的学习资料官方介绍如是说分布式系统使用作为配置管理服务发现和协调分布式工作的一致键值存储许多组织使用来实现生产系统如容器调度器服务发现服务和分布式数据存储使用的常见分布式模式包括选举分布式锁和监视机器活动实现分布式锁仅是众多功能中的一项服务注册与发现在中用的则会更多官方也对众多组件进行了对比如下所示实现分布式锁的组件们在分布式系统中常用于实现分布式锁的组件有下面针对各自的特性进行对比备注可用中的含义为集群节点数的一半例如集群节点数为则为则为也就是说保证集群中超过半数节点可用由上图可以看出组件各自的特点对于分布式锁来说在某些场景下可能至关重要的一点是要求但是一般情况下集群不支持而是支持虽然官方也给出了的方案但由于需要部署多个实例超过一半实例成功才视为成功部署维护比较复杂可能还会存在一些问题所以在对一致性要求很高的业务场景下电商银行支付一般选择使用或者对比与如果考虑性能并发量维护成本来看由于是用语言开发直接编译为二进制可执行文件并不依赖其他任何东西则更具有优势分布式锁实现原理对于分布式锁来说操作的动作包含获取锁处理过程中需要另起线程协程对锁进行续约防止锁被释放时业务还未处理完成释放锁分布式锁示例代码官方已经对分布式锁进行了封装这里使用官方示例来讲解创建对象为端的地址这里连接到本地的用完关闭连接通过创建会话注意会话中包含一个租约在后面创建时与进行绑定从而进行保活写法写法这里只是随便写一个数值具体的还需要创建用完关闭创建锁锁的前缀为创建会话锁通过取获取锁等于说明获得到了锁因为锁被持有了此时不应该获得到锁走到这里说明除了问题释放锁试图去获取锁因为已经释放了锁所以会成功获取到锁源码解读通过示例可以看出使用实现分布式锁非常方便调用的方法主要有创建一个带有租约的会话创建实现锁的对象如果锁被其他持有则会一直阻塞到能获取到锁如果锁被其他持有则不会阻塞而是直接返回释放锁对会话解读默认秒会话选项租约客户端对象选项租约这里先设置为默认值如果包含用于设置的方法就会使用配置的值覆盖默认值租约如果包含用于设置的方法则大于为常量也就是说未设置租约则会根据创建租约走到这里时中已经包含了一个可用的租约对保活相当于中设置的过期时间一旦到达过期时间就会被删除是为了不停的给续约以防止业务还没处理完成就被释放了封装的库中有这里的就相当于是一个从读取值却不用是因为的缓冲区大小固定否则被填满之后可能会造成阻塞从而出现问题对锁对象解读对象包含租约需要跟进行绑定锁前缀最终锁的即锁前缀租约的请求获取锁时返回的信息创建锁对象对加锁方法的解读很关键尝试加锁核心持有锁中的即当前是谁持有的这把锁如果还没有持有这把锁则如果持有锁的人是自己则只要符合上面个条件就说明是自己获得了锁获得了锁直接返回没有获得到锁需要则阻塞等待锁的释放为了避免惊群效应只监听比自己小的前一个表示自己只关心比自己小的而这个最大是唯一不同的是这里调用的是方法不会阻塞再次确认一下还未过期尝试去加锁客户端对象最终的为前缀租约判断的是否为为则表示还不存在重要在这里可以看到租约与进行绑定看到这里是即前缀而不是完整的表示获取最先创建的即最小的为判断条件为创建为查询为查询持有前缀的最小的信息注意这里使用了的事务写法语义类似于编程语言中的伪代码如下执行中包含的动作动作可以是多个执行中执行的动作动作可以是多个一句话概括判断是否存在不存在则执行存在则执行由于需要请求远端的所以只有在调用时才会发起对远端的调用执行上面的逻辑如果为则为否则为则为为了更好地说明获取锁的过程假设存在个分别创建属于自己的由于最先创建所以只有获得了锁此时只监听比自己小并且距离自己最近的的删除事件一旦删除了则获得锁同理只监听比自己小并且距离自己最近的的删除事件删除了则获得锁对监听删除事件的方法的解读注意这里比较核心比自己小并且距离自己最近的通过着两个条件来限制自己关注的长什么样子关注的的按照倒序排列只取一个关注的的最大为先获取关注并且将要的的信息监听的即比自己小并且距离自己最近的中监听关注的无事件发生则一直阻塞为对应的的对进行监听为的有任何事件发生之后都会从中获取的到事件信息只关注删除事件正常情况下只有删除事件发生才会退出对删除方法的解读请求对进行删除操作把重置为码值为的字符即小结好的分布式锁应该具备一下几点互斥性任意时刻同一个锁只有一个操作对象能持有通过对的相同前缀加锁最小者获得锁实现安全性避免死锁当进程没有主动释放锁进程崩溃退出保证其他进程能够加锁通过对的相同前缀加锁非最小者创建并阻塞等待可用性当提供锁的服务节点故障宕机时热备节点能够接替故障的节点继续提供服务并保证自身持有的数据与故障节点一致通过一致性算法来保证的主从集群或者算法在这里可能会存在一些问题对称性对同一个锁加锁和解锁必须是同一个进程即某进程不能把其他进程持有的锁给释放了每一个加锁对象都会有一个对象解锁时删除的是完整的名称而非前缀使用前缀保证了的唯一性通过源码解读可知具备上述特性并且是一把合格的分布式锁扩展阅读交互中含义',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-08 15:38:53',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">极客之道</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="anzhiyufont anzhiyu-icon-house-chimney faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/booklist/"><i class="anzhiyufont anzhiyu-icon-book faa-tada"></i><span> 书单</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada"></i><span> 关于</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url">中间件</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>中间件</span></a></span></div></div><h1 class="post-title" itemprop="name headline">etcd与分布式锁的实现及原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-05-24T00:29:00.000Z" title="发表于 2021-05-24 08:29:00">2021-05-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-07-08T07:38:53.257Z" title="更新于 2024-07-08 15:38:53">2024-07-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">3.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="etcd与分布式锁的实现及原理"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/space-man-small.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.ivansli.com/2021/05/24/etcd-lock/"><header><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url">中间件</a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" tabindex="-1" itemprop="url">中间件</a><h1 id="CrawlerTitle" itemprop="name headline">etcd与分布式锁的实现及原理</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ivansli</span><time itemprop="dateCreated datePublished" datetime="2021-05-24T00:29:00.000Z" title="发表于 2021-05-24 08:29:00">2021-05-24</time><time itemprop="dateCreated datePublished" datetime="2024-07-08T07:38:53.257Z" title="更新于 2024-07-08 15:38:53">2024-07-08</time></header><h2 id="1-关于etcd"><a href="#1-关于etcd" class="headerlink" title="1.关于etcd"></a>1.关于etcd</h2><p>官方文档永远是最好的学习资料，官方介绍etcd如是说。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/07/2128363047.png"></p>
<blockquote>
<p>分布式系统使用etcd作为配置管理、服务发现和协调分布式工作的一致键值存储。许多组织使用etcd来实现生产系统，如容器调度器、服务发现服务和分布式数据存储。使用etcd的常见分布式模式包括leader选举、分布式锁和监视机器活动。</p>
</blockquote>
<blockquote>
<p>Distributed systems use etcd as a consistent key-value store for configuration management, service discovery, and coordinating distributed work. Many organizations use etcd to implement production systems such as container schedulers, service discovery services, and distributed data storage. Common distributed patterns using etcd include leader election, distributed locks, and monitoring machine liveness.</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://etcd.io/docs/v3.4/learning/why/">https://etcd.io/docs/v3.4/learning/why/</a></p>
</blockquote>
<p>实现分布式锁仅是 etcd 众多功能中的一项，服务注册与发现在 etcd 中用的则会更多。</p>
<p>官方也对众多组件进行了对比，如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/07/1157747113.png">


<h2 id="2-实现分布式锁的组件们"><a href="#2-实现分布式锁的组件们" class="headerlink" title="2.实现分布式锁的组件们"></a>2.实现分布式锁的组件们</h2><p>在分布式系统中，常用于实现分布式锁的组件有：Redis、zookeeper、etcd，下面针对各自的特性进行对比：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/07/2994759155.png"></p>
<blockquote>
<p>备注：<code>N+1可用</code> 中的 <code>N</code> 含义为 <code>集群节点数的一半</code><br>例如，etcd集群节点数为5，则 N 为 5&#x2F;2&#x3D;2，则 <code>N+1</code> 为3，也就是说保证集群中超过半数节点可用。</p>
</blockquote>
<p>由上图可以看出组件各自的特点，对于分布式锁来说在某些场景下可能至关重要的一点是要求CP。但是，一般情况下Redis集群不支持CP，而是支持AP。虽然，官方也给出了redlock的方案，但由于需要部署多个实例（超过一半实例成功才视为成功），部署、维护比较复杂、可能还会存在一些问题。所以在对一致性要求很高的业务场景下（电商、银行支付），一般选择使用zookeeper或者etcd。对比zookeeper与etcd，如果考虑性能、并发量、维护成本来看。由于etcd是用Go语言开发，直接编译为二进制可执行文件，并不依赖其他任何东西，则更具有优势。</p>
<h2 id="3-etcd分布式锁实现原理"><a href="#3-etcd分布式锁实现原理" class="headerlink" title="3.etcd分布式锁实现原理"></a>3.etcd分布式锁实现原理</h2><p>对于分布式锁来说，操作的动作包含：<br>1.获取锁</p>
<blockquote>
<p>处理过程中，需要另起线程&#x2F;协程对锁进行续约，防止锁被释放时业务还未处理完成。</p>
</blockquote>
<p>2.释放锁</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/07/606101614.png">


<h2 id="4-etcd分布式锁示例代码"><a href="#4-etcd分布式锁示例代码" class="headerlink" title="4.etcd分布式锁示例代码"></a>4.etcd分布式锁示例代码</h2><p>官方已经对 etcd 分布式锁进行了封装，这里使用官方示例来讲解。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/blob/main/tests/integration/clientv3/concurrency/example_mutex_test.go">https://github.com/etcd-io/etcd/blob/main/tests/integration/clientv3/concurrency/example_mutex_test.go</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;go.etcd.io/etcd/client/v3&quot;</span></span><br><span class="line">	<span class="string">&quot;go.etcd.io/etcd/client/v3/concurrency&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMutex_TryLock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建 etcd client 对象</span></span><br><span class="line">	<span class="comment">// Endpoints 为 etcd server 端的地址，这里连接到本地的 etcd server</span></span><br><span class="line">	cli, err := clientv3.New(clientv3.Config&#123;Endpoints: []<span class="type">string</span>&#123;<span class="string">&quot;127.0.0.1:2379&quot;</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用完关闭连接</span></span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create two separate sessions for lock competition</span></span><br><span class="line">	<span class="comment">// 通过 etcd client 创建 session 会话</span></span><br><span class="line">	<span class="comment">// 注意：session 会话中包含一个租约，在后面创建 etcd key 时，与 key 进行绑定，从而进行保活</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写法1</span></span><br><span class="line">	<span class="comment">//s1, err := concurrency.NewSession(cli, concurrency.WithTTL(10))</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 写法2</span></span><br><span class="line">	<span class="comment">//leaseId:=100 // 这里只是随便写一个数值，具体的还需要创建</span></span><br><span class="line">	<span class="comment">//s1, err :=concurrency.NewSession(cli,concurrency.WithLease(clientv3.LeaseID(leaseId)))</span></span><br><span class="line"></span><br><span class="line">	s1, err := concurrency.NewSession(cli)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用完关闭</span></span><br><span class="line">	<span class="keyword">defer</span> s1.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 锁1，锁的 key 前缀为 /my-lock</span></span><br><span class="line">	m1 := concurrency.NewMutex(s1, <span class="string">&quot;/my-lock&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建会话2</span></span><br><span class="line">	s2, err := concurrency.NewSession(cli)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> s2.Close()</span><br><span class="line">	<span class="comment">// 锁2</span></span><br><span class="line">	m2 := concurrency.NewMutex(s2, <span class="string">&quot;/my-lock&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// acquire lock for s1</span></span><br><span class="line">	<span class="comment">// 通过 m1 取获取锁</span></span><br><span class="line">	<span class="comment">// err 等于 nil 说明获得到了 锁</span></span><br><span class="line">	<span class="keyword">if</span> err = m1.Lock(context.TODO()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;acquired lock for s1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err = m2.Lock(context.TODO()); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 因为，锁被 m1 持有了，此时 m2 不应该获得到锁，走到这里说明除了问题</span></span><br><span class="line">		log.Fatal(<span class="string">&quot;should not acquire lock&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == concurrency.ErrLocked &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;cannot acquire lock for s2, as already locked in another session&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// m1 释放锁</span></span><br><span class="line">	<span class="keyword">if</span> err = m1.Unlock(context.TODO()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;released lock for s1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// m2 试图去获取锁</span></span><br><span class="line">	<span class="comment">// 因为 m1 已经释放了锁，所以 m2 会成功获取到锁</span></span><br><span class="line">	<span class="keyword">if</span> err = m2.TryLock(context.TODO()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;acquired lock for s2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// acquired lock for s1</span></span><br><span class="line">	<span class="comment">// cannot acquire lock for s2, as already locked in another session</span></span><br><span class="line">	<span class="comment">// released lock for s1</span></span><br><span class="line">	<span class="comment">// acquired lock for s2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-源码解读"><a href="#5-源码解读" class="headerlink" title="5.源码解读"></a>5.源码解读</h2><p>通过示例可以看出，使用 etcd 实现分布式锁非常方便，调用的方法主要有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NewSession gets the leased session for a client.</span></span><br><span class="line"><span class="comment">// 创建一个 带有租约 的会话</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(client *v3.Client, opts ...SessionOption)</span></span> (*Session, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 实现锁的 对象 Mutex</span></span><br><span class="line"><span class="comment">// Mutex implements the sync Locker interface with etcd</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">(s *Session, pfx <span class="type">string</span>)</span></span> *Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock locks the mutex with a cancelable context. If the context is canceled</span></span><br><span class="line"><span class="comment">// while trying to acquire the lock, the mutex tries to clean its stale lock entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果锁被其他 session 持有，则会一直阻塞到能获取到锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock(ctx context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TryLock locks the mutex if not already locked by another session.</span></span><br><span class="line"><span class="comment">// If lock is held by another session, return immediately after attempting necessary cleanup</span></span><br><span class="line"><span class="comment">// The ctx argument is used for the sending/receiving Txn RPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果锁被其他 session 持有，则不会阻塞，而是直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> TryLock(ctx context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock(ctx context.Context) <span class="type">error</span></span><br></pre></td></tr></table></figure>


<p>对会话 Session 解读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// session ttl 默认 60秒</span></span><br><span class="line"><span class="keyword">const</span> defaultSessionTTL = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session 会话选项</span></span><br><span class="line"><span class="keyword">type</span> sessionOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">	ttl     <span class="type">int</span> <span class="comment">// time to live</span></span><br><span class="line">	leaseID v3.LeaseID <span class="comment">// 租约id</span></span><br><span class="line"></span><br><span class="line">	ctx     context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Session represents a lease kept alive for the lifetime of a client.</span></span><br><span class="line"><span class="comment">// Fault-tolerant applications may use sessions to reason about liveness.</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">	client *v3.Client <span class="comment">// etcd 客户端对象</span></span><br><span class="line">	opts   *sessionOptions <span class="comment">// session 选项</span></span><br><span class="line">	id     v3.LeaseID <span class="comment">// 租约id</span></span><br><span class="line"></span><br><span class="line">	cancel context.CancelFunc</span><br><span class="line">	donec  &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSession gets the leased session for a client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(client *v3.Client, opts ...SessionOption)</span></span> (*Session, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里先设置 session ttl 为默认值</span></span><br><span class="line">  <span class="comment">// 如果 opts 包含用于设置 ttl 的方法 `func WithTTL(ttl int) SessionOption` 就会使用配置的值覆盖默认值</span></span><br><span class="line">	ops := &amp;sessionOptions&#123;ttl: defaultSessionTTL, ctx: client.Ctx()&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		opt(ops)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 租约id</span></span><br><span class="line">  <span class="comment">// 如果 opts 包含用于设置 ttl 的方法 `func WithLease(leaseID v3.LeaseID) SessionOption` 则 ops.leaseID 大于 0</span></span><br><span class="line">	id := ops.leaseID</span><br><span class="line">  <span class="comment">// v3.NoLease 为 常量0。也就是说未设置 租约，则会根据 ttl 创建租约</span></span><br><span class="line">	<span class="keyword">if</span> id == v3.NoLease &#123;</span><br><span class="line">		resp, err := client.Grant(ops.ctx, <span class="type">int64</span>(ops.ttl))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		id = resp.ID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 走到这里时，session 中已经包含了一个可用的租约</span></span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(ops.ctx)</span><br><span class="line">  <span class="comment">// 对 leaseID 保活</span></span><br><span class="line">  <span class="comment">// lease 相当于 redis 中设置的过期时间。一旦到达过期时间，key就会被删除</span></span><br><span class="line">  <span class="comment">// KeepAlive() 是为了 不停的给 key 续约，以防止 业务还没处理完成，key就被释放了</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// java 封装的 redis 库中有 watchdog，这里的 KeepAlive() 就相当于 watchdog</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// keepAlive 是一个 chan</span></span><br><span class="line">	keepAlive, err := client.KeepAlive(ctx, id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || keepAlive == <span class="literal">nil</span> &#123;</span><br><span class="line">		cancel()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	donec := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	s := &amp;Session&#123;client: client, opts: ops, id: id, cancel: cancel, donec: donec&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep the lease alive until client error or cancelled context</span></span><br><span class="line">  <span class="comment">// 从 keepAlive 读取值，却不用是因为 keepAlive 的缓冲区大小固定，否则被填满之后可能会造成阻塞，从而出现问题</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(donec)</span><br><span class="line">		<span class="keyword">for</span> <span class="keyword">range</span> keepAlive &#123;</span><br><span class="line">			<span class="comment">// eat messages until keep alive channel closes</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对锁对象 Mutex 解读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	s *Session <span class="comment">// session 对象，包含租约id，需要跟 mykey 进行绑定</span></span><br><span class="line"></span><br><span class="line">	pfx   <span class="type">string</span> <span class="comment">// 锁前缀</span></span><br><span class="line">	myKey <span class="type">string</span> <span class="comment">// 最终锁的 key = pfx+s.id，即：锁前缀+租约id</span></span><br><span class="line">	myRev <span class="type">int64</span>  <span class="comment">// key 的 Revision</span></span><br><span class="line"></span><br><span class="line">	hdr   *pb.ResponseHeader <span class="comment">// 请求 etcd server 获取锁时，返回的 header 信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutex</span><span class="params">(s *Session, pfx <span class="type">string</span>)</span></span> *Mutex &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Mutex&#123;s, pfx + <span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对加锁方法 Lock 的解读 (很关键)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks the mutex with a cancelable context. If the context is canceled</span></span><br><span class="line"><span class="comment">// while trying to acquire the lock, the mutex tries to clean its stale lock entry.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 尝试加锁（核心）</span></span><br><span class="line">	resp, err := m.tryAcquire(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if no key on prefix / the minimum rev is key, already hold the lock</span></span><br><span class="line">  <span class="comment">// 持有锁 session 中 pfx 的 kvs，即：当前是谁持有的这把锁</span></span><br><span class="line">	ownerKey := resp.Responses[<span class="number">1</span>].GetResponseRange().Kvs</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ① 如果还没有持有这把锁，则 len(ownerKey) == 0</span></span><br><span class="line">  <span class="comment">// ② 如果持有锁的人是自己，则 ownerKey[0].CreateRevision == m.myRev</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 只要符合上面2个条件，就说明是自己获得了锁</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ownerKey) == <span class="number">0</span> || ownerKey[<span class="number">0</span>].CreateRevision == m.myRev &#123;</span><br><span class="line">		m.hdr = resp.Header</span><br><span class="line">    <span class="comment">// 获得了锁，直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client := m.s.Client()</span><br><span class="line">	<span class="comment">// wait for deletion revisions prior to myKey</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> early termination if the session key is deleted before other session keys with smaller revisions.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有获得到锁，需要则阻塞等待锁的释放</span></span><br><span class="line">  <span class="comment">// 为了避免惊群效应，只监听比自己小的前一个 key </span></span><br><span class="line">  <span class="comment">// m.myRev-1 表示自己只关心比自己小的 Revision，而这个 Revision 最大是 m.myRev-1</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TryLock() 唯一不同的是这里调用的是 client.Delete() 方法。不会阻塞</span></span><br><span class="line">  _, werr := waitDeletes(ctx, client, m.pfx, m.myRev<span class="number">-1</span>)</span><br><span class="line">	<span class="comment">// release lock key if wait failed</span></span><br><span class="line">	<span class="keyword">if</span> werr != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.Unlock(client.Ctx())</span><br><span class="line">		<span class="keyword">return</span> werr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make sure the session is not expired, and the owner key still exists.</span></span><br><span class="line">  <span class="comment">// 再次确认一下 session 还未过期</span></span><br><span class="line">	gresp, werr := client.Get(ctx, m.myKey)</span><br><span class="line">	<span class="keyword">if</span> werr != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.Unlock(client.Ctx())</span><br><span class="line">		<span class="keyword">return</span> werr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(gresp.Kvs) == <span class="number">0</span> &#123; <span class="comment">// is the session key lost?</span></span><br><span class="line">		<span class="keyword">return</span> ErrSessionExpired</span><br><span class="line">	&#125;</span><br><span class="line">	m.hdr = gresp.Header</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试去加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> tryAcquire(ctx context.Context) (*v3.TxnResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// session</span></span><br><span class="line">  s := m.s</span><br><span class="line">  <span class="comment">// etcd 客户端对象</span></span><br><span class="line">	client := m.s.Client()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最终的key 为 key前缀+租约id</span></span><br><span class="line">	m.myKey = fmt.Sprintf(<span class="string">&quot;%s%x&quot;</span>, m.pfx, s.Lease())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 m.myKey 的 create_vison是否为0</span></span><br><span class="line">  <span class="comment">// 为 0, 则表示 m.myKey 还不存在</span></span><br><span class="line">	cmp := v3.Compare(v3.CreateRevision(m.myKey), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// put self in lock waiters via myKey; oldest waiter holds lock</span></span><br><span class="line">  <span class="comment">// （重要）在这里可以看到 租约id 与 m.myKey 进行绑定</span></span><br><span class="line">	put := v3.OpPut(m.myKey, <span class="string">&quot;&quot;</span>, v3.WithLease(s.Lease()))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reuse key in case this session already holds the lock</span></span><br><span class="line">	get := v3.OpGet(m.myKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fetch current holder to complete uncontended path with only one RPC</span></span><br><span class="line">  <span class="comment">// 看到这里是 m.pfx，即：key前缀，而不是完整的key</span></span><br><span class="line">  <span class="comment">// v3.WithFirstCreate() 表示获取最先创建的，即：Revision最小的</span></span><br><span class="line">	getOwner := v3.OpGet(m.pfx, v3.WithFirstCreate()...)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cmp 为判断条件</span></span><br><span class="line">  <span class="comment">// put 为创建 key</span></span><br><span class="line">  <span class="comment">// get 为查询 key</span></span><br><span class="line">  <span class="comment">// getOwner 为查询持有key前缀 m.pfx 的最小的 Revision 信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意：这里使用了 etcd 的 事务写法</span></span><br><span class="line">  <span class="comment">// If(cmp).Then().Else().Commit() 语义类似于编程语言中的 if ... else ...，伪代码如下</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// if (cmp) &#123;</span></span><br><span class="line">  <span class="comment">//   //执行 then 中包含的动作（动作可以是多个）</span></span><br><span class="line">  <span class="comment">//   Then()</span></span><br><span class="line">  <span class="comment">// &#125;else&#123;</span></span><br><span class="line">  <span class="comment">//   //执行 else 中执行的动作（动作可以是多个）</span></span><br><span class="line">  <span class="comment">//   Else()</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 一句话概括：判断 m.myKey 是否存在，不存在则执行 Then()，存在则执行 Else()。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 由于需要请求远端的 etcd server，所以只有在 调用 Commit() 时，才会发起对远端的调用执行上面的逻辑</span></span><br><span class="line">	resp, err := client.Txn(ctx).If(cmp).Then(put, getOwner).Else(get, getOwner).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.myRev = resp.Header.Revision</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 cmp 为 true，则 resp.Succeeded  为true</span></span><br><span class="line">  <span class="comment">// 否则 cmp 为 false，则 resp.Succeeded 为false</span></span><br><span class="line">	<span class="keyword">if</span> !resp.Succeeded &#123;</span><br><span class="line">		m.myRev = resp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>].CreateRevision</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更好地说明获取锁的过程，假设存在3个client（client1、client2、client3）分别创建属于自己的key <code>/my-lock/uuid1</code>、<code>/my-lock/uuid2</code>、<code>/my-lock/uuid3</code>，由于client1最先创建，所以只有 client1获得了锁。<br>此时，client2 只监听比自己Revision小并且距离自己Revision最近的key <code>/my-lock/uuid1</code> 的删除事件，一旦 client1 删除了 <code>/my-lock/uuid1</code>，则 client2获得锁。<br>同理，client3 只监听比自己Revision小并且距离自己Revision最近的key <code>/my-lock/uuid2</code> 的删除事件，client2 删除了 <code>/my-lock/uuid2</code>，则 client3获得锁。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/07/352142567.png">


<p>对监听key删除事件的 waitDeletes() 方法的解读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// waitDeletes efficiently waits until all keys matching the prefix and no greater</span></span><br><span class="line"><span class="comment">// than the create revision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitDeletes</span><span class="params">(ctx context.Context, client *v3.Client, pfx <span class="type">string</span>, maxCreateRev <span class="type">int64</span>)</span></span> (*pb.ResponseHeader, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 注意：这里比较核心，比自己Revision小并且距离自己Revision最近的key</span></span><br><span class="line">  <span class="comment">// 通过 v3.WithLastCreate()、v3.WithMaxCreateRev(maxCreateRev) 着两个条件来限制自己关注的key长什么样子</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// v3.WithLastCreate() 关注的key的 按照 CreateRevision 倒序排列，只取一个</span></span><br><span class="line">  <span class="comment">// v3.WithMaxCreateRev(maxCreateRev) 关注的key的Revision最大为 maxCreateRev</span></span><br><span class="line">  getOpts := <span class="built_in">append</span>(v3.WithLastCreate(), v3.WithMaxCreateRev(maxCreateRev))</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 先获取关注并且将要 watch 的 key 的信息</span></span><br><span class="line">		resp, err := client.Get(ctx, pfx, getOpts...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(resp.Kvs) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> resp.Header, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听的 key，即：比自己Revision小并且距离自己Revision最近的key</span></span><br><span class="line">		lastKey := <span class="type">string</span>(resp.Kvs[<span class="number">0</span>].Key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitDelete 中 监听key</span></span><br><span class="line">    <span class="comment">// 关注的 key 无事件发生，则一直阻塞</span></span><br><span class="line">    <span class="comment">// resp.Header.Revision 为 对应的key的 Revision</span></span><br><span class="line">		<span class="keyword">if</span> err = waitDelete(ctx, client, lastKey, resp.Header.Revision); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitDelete</span><span class="params">(ctx context.Context, client *v3.Client, key <span class="type">string</span>, rev <span class="type">int64</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	cctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wr v3.WatchResponse</span><br><span class="line">  <span class="comment">// 对 key 进行监听</span></span><br><span class="line">  <span class="comment">// rev 为 key 的 Revision</span></span><br><span class="line">	wch := client.Watch(cctx, key, v3.WithRev(rev))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key有任何事件发生之后，都会从 wch 中获取的到事件信息</span></span><br><span class="line">	<span class="keyword">for</span> wr = <span class="keyword">range</span> wch &#123;</span><br><span class="line">		<span class="keyword">for</span> _, ev := <span class="keyword">range</span> wr.Events &#123;</span><br><span class="line">      <span class="comment">// 只关注 删除事件</span></span><br><span class="line">      <span class="comment">// 正常情况下，只有 删除事件发生，才会退出</span></span><br><span class="line">			<span class="keyword">if</span> ev.Type == mvccpb.DELETE &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := wr.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := ctx.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;lost watcher waiting for delete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对删除key Unlock() 方法的解读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	client := m.s.Client()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求 etcd server 对key进行删除操作</span></span><br><span class="line">	<span class="keyword">if</span> _, err := client.Delete(ctx, m.myKey); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 m.myKey 重置为 ASCII 码值为 0 的字符，即：</span></span><br><span class="line">	m.myKey = <span class="string">&quot;\x00&quot;</span></span><br><span class="line">	m.myRev = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/07/1757855868.png">


<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好的分布式锁应该具备一下几点：</p>
<ul>
<li><p>互斥性：任意时刻，同一个锁，只有一个操作对象能持有</p>
<blockquote>
<p>etcd 通过对key的相同前缀加锁，Revision 最小者获得锁实现</p>
</blockquote>
</li>
<li><p>安全性：避免死锁，当进程没有主动释放锁（进程崩溃退出），保证其他进程能够加锁</p>
<blockquote>
<p>etcd 通过对key的相同前缀加锁，Revision 非最小者创建key并阻塞等待</p>
</blockquote>
</li>
<li><p>可用性：当提供锁的服务节点故障（宕机）时，热备节点能够接替故障的节点继续提供服务，并保证自身持有的数据与故障节点一致</p>
<blockquote>
<p>etcd server 通过raft一致性算法来保证<br>redis 的主从集群 或者 Redlock算法 在这里可能会存在一些问题</p>
</blockquote>
</li>
<li><p>对称性：对同一个锁，加锁和解锁必须是同一个进程，即某进程不能把其他进程持有的锁给释放了</p>
<blockquote>
<p>每一个加锁对象都会有一个 mutex 对象，解锁时删除的是 完整的 key 名称，而非前缀。etcd 使用 <code>key前缀+uuid</code> 保证了key的唯一性</p>
</blockquote>
</li>
</ul>
<p>通过源码解读，可知 etcd 具备上述特性，并且是一把合格的分布式锁。</p>
<h2 id="7-扩展阅读"><a href="#7-扩展阅读" class="headerlink" title="7.扩展阅读"></a>7.扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://doczhcn.gitbook.io/etcd/index/index/interacting_v3">https://doczhcn.gitbook.io/etcd/index/index/interacting_v3</a> etcd交互</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/FengZeng666/p/16156407.html">https://www.cnblogs.com/FengZeng666/p/16156407.html</a> etcd中Revision&#x2F;CreateRevision&#x2F;ModRevision&#x2F;Version含义</li>
<li><a target="_blank" rel="noopener" href="https://pandaychen.github.io/2020/05/30/A-ETCD-COOKBOOK/">https://pandaychen.github.io/2020/05/30/A-ETCD-COOKBOOK/</a></li>
<li><a target="_blank" rel="noopener" href="https://pandaychen.github.io/2019/10/24/ETCD-DISTRIBUTED-LOCK/">https://pandaychen.github.io/2019/10/24/ETCD-DISTRIBUTED-LOCK/</a></li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/xiaowangzi.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/xiaowangzi.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">ivansli</div><div class="post-copyright__author_desc">学无止境</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.ivansli.com/2021/05/24/etcd-lock/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.ivansli.com/2021/05/24/etcd-lock/')">etcd与分布式锁的实现及原理</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><!--span.reward-title 感谢你赐予我前进的力量--><ul class="reward-group"><li class="reward-item"><a href="/img/reward/wechat-small.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/reward/wechat-small.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/reward/alipay-small.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/reward/alipay-small.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><!--a.reward-main-btn(href='/about/#about-reward' target='_blank')//.reward-text 赞赏者名单
//.reward-dec 因为你们的支持让我意识到写文章的价值🙏--></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.ivansli.com/2021/05/24/etcd-lock/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=etcd与分布式锁的实现及原理&amp;url=https://blog.ivansli.com/2021/05/24/etcd-lock/&amp;pic=/img/space-man-small.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文系原创作品，版权所有（禁止转载）</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>中间件<span class="tagsPageCount">13</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/2024/07/helm.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/23/linux-crontab/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/space-man-small.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">crontab定时任务设置超时、互斥</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/25/about-unix/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2021/11/1965466339.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix传奇发展史</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/230426-redis-server/" title="redisServer、redisDB与数据字典dict"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/04/redis-server-layout.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">redisServer、redisDB与数据字典dict</div></div></a></div><div><a href="/2023/04/27/230427-redis-config/" title="关于Redis配置信息初始化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/04/redis-config-001.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-27</div><div class="title">关于Redis配置信息初始化</div></div></a></div><div><a href="/2023/05/30/230530-redis-event-driven/" title="Redis事件驱动(aeEventLoop)原理分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/05/2023530-01.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-30</div><div class="title">Redis事件驱动(aeEventLoop)原理分析</div></div></a></div><div><a href="/2023/06/02/230602-redis-cluster-hashtag/" title="Redis Cluster集群hash tag原理分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/06/230602-01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-02</div><div class="title">Redis Cluster集群hash tag原理分析</div></div></a></div><div><a href="/2021/05/18/distributed-lock/" title="使用分布式锁时要考虑的事情"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/space-man-small.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-18</div><div class="title">使用分布式锁时要考虑的事情</div></div></a></div><div><a href="/2022/06/21/gitlab-ci-cd/" title="基于docker搭建的gitlab实现CI&#x2F;CD"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2022/06/312466126.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-06-21</div><div class="title">基于docker搭建的gitlab实现CI&#x2F;CD</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/xiaowangzi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/goutou.png" ait="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这里有<b style="color:#fff">知识总结</b>和<b style="color:#fff">技术分享</b>。书山有路勤为径，学海无涯苦作舟。<b style="color:#fff">此生也有涯</b>，<b style="color:#fff">此生学无涯</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ivansli</h1><div class="author-info__desc">学无止境</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/coderstart" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E4%BA%8Eetcd"><span class="toc-number">1.</span> <span class="toc-text">1.关于etcd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BB%AC"><span class="toc-number">2.</span> <span class="toc-text">2.实现分布式锁的组件们</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-etcd%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.etcd分布式锁实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-etcd%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">4.etcd分布式锁示例代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">5.</span> <span class="toc-text">5.源码解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">6.小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">7.扩展阅读</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/07/240707-helm/" title="helm的安装/使用及其运行原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2024/07/helm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="helm的安装/使用及其运行原理"/></a><div class="content"><a class="title" href="/2024/07/07/240707-helm/" title="helm的安装/使用及其运行原理">helm的安装/使用及其运行原理</a><time datetime="2024-07-07T01:00:00.000Z" title="发表于 2024-07-07 09:00:00">2024-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/11/theroadtoserfdom/" title="读：哈耶克《到奴役之路》有感"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/11/hayeke.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="读：哈耶克《到奴役之路》有感"/></a><div class="content"><a class="title" href="/2023/11/11/theroadtoserfdom/" title="读：哈耶克《到奴役之路》有感">读：哈耶克《到奴役之路》有感</a><time datetime="2023-11-11T01:44:00.000Z" title="发表于 2023-11-11 09:44:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/231007-game-theory3/" title="二人零和博弈与最大最小定理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/09/gametheory-01.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二人零和博弈与最大最小定理"/></a><div class="content"><a class="title" href="/2023/10/07/231007-game-theory3/" title="二人零和博弈与最大最小定理">二人零和博弈与最大最小定理</a><time datetime="2023-10-07T08:45:00.000Z" title="发表于 2023-10-07 16:45:00">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/231007-game-theory2/" title="博弈论对一般问题的建模分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/09/gametheory-01.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博弈论对一般问题的建模分析"/></a><div class="content"><a class="title" href="/2023/10/07/231007-game-theory2/" title="博弈论对一般问题的建模分析">博弈论对一般问题的建模分析</a><time datetime="2023-10-07T03:40:00.000Z" title="发表于 2023-10-07 11:40:00">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/18/230918-game-theory/" title="认识博弈论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/2023/09/gametheory-01.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="认识博弈论"/></a><div class="content"><a class="title" href="/2023/09/18/230918-game-theory/" title="认识博弈论">认识博弈论</a><time datetime="2023-09-18T10:00:00.000Z" title="发表于 2023-09-18 18:00:00">2023-09-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><!-- - let centerImg = theme.footer.socialBar.centerImg ? theme.footer.socialBar.centerImg : theme.avatar.img--><div id="footer_deal"><!-- 左侧图标--><a class="deal_link" href="mailto:gopher001@outlook.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><!--个人头像图标--><!--img.footer_mini_logo(title="返回顶部", alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)", src=centerImg, size="50px")--><!-- 右侧图标--><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/coderstart" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="文章列表" href="/archives/">文章列表</a><a class="footer-item" title="我的书单" href="/booklist/">我的书单</a><a class="footer-item" title="极客说说" href="/essay/">极客说说</a><a class="footer-item" title="关于本站" href="/about/">关于本站</a></div></div><div class="footer-group"><div class="footer-title">分类</div><div class="footer-links"><a class="footer-item" title="编程原理" href="/categories/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/">编程原理</a><a class="footer-item" title="系统架构" href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a><a class="footer-item" title="中间件" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a class="footer-item" title="编程原理" href="/categories/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/">编程原理</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title">友链</div><div class="footer-links"><a class="footer-item" title="编程导航" href="/tool/">编程导航</a></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" style="margin-inline:5px" data-title="博客框架为Hexo" title="博客框架为Hexo"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo"/></a><a class="github-badge" target="_blank" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/badge/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2019 - 2024 · <a class="footer-bar-link" href="/" title="ivansli" target="_blank">ivansli</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="http://beian.miit.gov.cn" title="沪ICP备2021031949号">沪ICP备2021031949号</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://tool.ivansli.com" title="编程导航">编程导航</a><a class="footer-bar-link cc" href="/" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">20</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="anzhiyufont anzhiyu-icon-house-chimney faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/booklist/"><i class="anzhiyufont anzhiyu-icon-book faa-tada"></i><span> 书单</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada"></i><span> 关于</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Apple/" style="font-size: 0.88rem;">Apple<sup>2</sup></a><a href="/tags/CI-CD/" style="font-size: 0.88rem;">CI/CD<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 0.88rem;">Docker<sup>2</sup></a><a href="/tags/IoT/" style="font-size: 0.88rem;">IoT<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>5</sup></a><a href="/tags/PHP/" style="font-size: 0.88rem;">PHP<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>1</sup></a><a href="/tags/Unix/" style="font-size: 0.88rem;">Unix<sup>2</sup></a><a href="/tags/ZooKeeper/" style="font-size: 0.88rem;">ZooKeeper<sup>1</sup></a><a href="/tags/crontab/" style="font-size: 0.88rem;">crontab<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>4</sup></a><a href="/tags/gitlab/" style="font-size: 0.88rem;">gitlab<sup>1</sup></a><a href="/tags/golang/" style="font-size: 0.88rem;">golang<sup>31</sup></a><a href="/tags/grpc-go/" style="font-size: 0.88rem;">grpc-go<sup>3</sup></a><a href="/tags/k8s/" style="font-size: 0.88rem;">k8s<sup>1</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>6</sup></a><a href="/tags/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">中文编程<sup>1</sup></a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 0.88rem;">中间件<sup>13</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/" style="font-size: 0.88rem;">分布式ID<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">分布式锁<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 0.88rem;">博弈论<sup>3</sup></a><a href="/tags/%E5%8F%B7%E6%AE%B5%E5%8F%91%E5%8F%B7%E5%99%A8/" style="font-size: 0.88rem;">号段发号器<sup>1</sup></a><a href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" style="font-size: 0.88rem;">常见问题<sup>6</sup></a><a href="/tags/%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF/" style="font-size: 0.88rem;">指数退避<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 0.88rem;">消息队列<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/" style="font-size: 0.88rem;">算法技巧<sup>6</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">系统架构<sup>5</sup></a><a href="/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/" style="font-size: 0.88rem;">经济学<sup>4</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%8E%86%E5%8F%B2/" style="font-size: 0.88rem;">编程历史<sup>8</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">编程原理<sup>31</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">编程工具<sup>1</sup></a><a href="/tags/%E8%81%8C%E5%9C%BA%E5%BF%83%E5%A3%B0/" style="font-size: 0.88rem;">职场心声<sup>1</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">软件工具<sup>2</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" style="font-size: 0.88rem;">面试经验<sup>4</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="/pluginsSrc/anzhiyu-theme-static/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="/pluginsSrc/anzhiyu-theme-static/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="/pluginsSrc/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="/pluginsSrc/anzhiyu-theme-static/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/anzhiyu-blog-static/js/APlayer.min.js"></script><script src="/pluginsSrc/hexo-anzhiyu-music/assets/js/Meting2.min.js"></script><script src="/pluginsSrc/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="/pluginsSrc/anzhiyu-theme-static/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>